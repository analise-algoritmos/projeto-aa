\chapter{Algoritmos com complexidades de tempo 
\texorpdfstring{$O(n)$}{O(n)}}

Nesta seção apresentamos algoritmos de ordenação cuja complexidade de tempo pode ser considerada linear em determinados cenários. Esses métodos exploram propriedades dos dados de entrada, como o tamanho do domínio ou a representação numérica. 

\textcolor{blue}{Sugiro que vocês expressem os cálculos das complexidades considerando as constantes envolvidas nas funções. Posso explicar isto na aula da segunda semana de outubro.}

\section{Counting sort}
\textbf{Descrição:} O Counting Sort não utiliza comparações entre elementos. Em vez disso, ele conta quantas vezes cada valor aparece e, com base nessas contagens, reconstrói o vetor ordenado. É especialmente eficiente quando os valores de entrada pertencem a um intervalo pequeno em relação ao número de elementos.

\begin{exmp}
Considere ordenar o vetor $A = [4, 2, 2, 8, 3, 3, 1]$ usando o \textit{Counting Sort}.  

\begin{enumerate}
    \item \textbf{Contagem da frequência:}  
    Criamos um vetor $count$ com tamanho igual ao maior valor de $A$ (neste caso, 8) e inicializamos com zeros.  
    Em seguida, contamos quantas vezes cada número aparece:  count = [0, 1, 2, 2, 1, 0, 0, 0, 1], onde $count[i]$ indica quantas vezes o número $i$ aparece em $A$.

    \item \textbf{Cálculo das posições acumuladas:}  
    Transformamos o vetor $count$ em um vetor de posições acumuladas, somando os valores anteriores: count = [0, 1, 3, 5, 6, 6, 6, 6, 7]. Agora, $count[i]$ indica a posição final do último elemento $i$ no vetor ordenado.

    \item \textbf{Reconstrução do vetor ordenado:}  
    Percorremos o vetor $A$ da direita para a esquerda e colocamos cada elemento na posição correta no vetor $output$:  output = [1, 2, 2, 3, 3, 4, 8]. Finalmente, copiamos o vetor $output$ de volta para $A$.

\end{enumerate}
\end{exmp}

\begin{center}
\begin{minipage}{.9\linewidth}
\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{countingSort(values: array of int, n: integer, k: integer)}

\For{$i \gets 0$ \KwTo $k$}{
    $count[i] \gets 0$\;
}
\For{$i \gets 0$ \KwTo $n-1$}{
    $count[values[i]] \gets count[values[i]] + 1$\;
}
\For{$i \gets 1$ \KwTo $k$}{
    $count[i] \gets count[i] + count[i-1]$\;
}
\For{$i \gets n-1$ \KwTo $0$}{
    $output[count[values[i]]-1] \gets values[i]$\;
    $count[values[i]] \gets count[values[i]] - 1$\;
}
\For{$i \gets 0$ \KwTo $n-1$}{
    $values[i] \gets output[i]$\;
}
\caption{Counting sort.}
\label{lab:alg-countingSort}
\end{algorithm}
\end{minipage}
\end{center}

\vspace{1em}

\begin{lstlisting}[language=C,caption={Counting sort em C},captionpos=t]
void countingSort(int arr[], int n, int k) {
    int count[k+1];
    int output[n];
    for(int i=0; i<=k; i++) count[i] = 0;
    for(int i=0; i<n; i++) count[arr[i]]++;
    for(int i=1; i<=k; i++) count[i] += count[i-1];
    for(int i=n-1; i>=0; i--) {
        output[count[arr[i]]-1] = arr[i];
        count[arr[i]]--;
    }
    for(int i=0; i<n; i++) arr[i] = output[i];
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Counting sort em C++},captionpos=t]
#include <vector>
using namespace std;

void countingSort(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> count(k + 1, 0), output(n);

    for (int num : arr)
        count[num]++;

    for (int i = 1; i <= k; i++)
        count[i] += count[i - 1];

    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }

    arr = output;
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Counting sort em Python},captionpos=t]
def counting_sort(arr, k):
    count = [0] * (k+1)
    output = [0] * len(arr)
    for num in arr:
        count[num] += 1
    for i in range(1, len(count)):
        count[i] += count[i-1]
    for num in reversed(arr):
        output[count[num]-1] = num
        count[num] -= 1
    return output
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-countingSort}}

Consideramos que o vetor $values$ tem comprimento $n$ e que os valores são inteiros no intervalo $[0, k]$. O algoritmo possui os seguintes \textit{loops}:

\begin{enumerate}
    \item Inicialização do vetor $count$ (tamanho $k+1$):
    \[
        \text{executa } k+1 \text{ atribuições em } O(1) \Rightarrow O(k)
    \]
    
    \item Contagem das ocorrências dos elementos do vetor $values$:
    \[
        n \text{ iterações, cada uma com operação } O(1) \Rightarrow O(n)
    \]
    
    \item Acúmulo das contagens no vetor $count$:
    \[
        k \text{ iterações, cada uma com operação } O(1) \Rightarrow O(k)
    \]
    
    \item Construção do vetor ordenado $output$:
    \[
        n \text{ iterações, cada uma com operação } O(1) \Rightarrow O(n)
    \]
    
    \item Cópia do vetor $output$ de volta para $values$:
    \[
        n \text{ iterações, cada uma com operação } O(1) \Rightarrow O(n)
    \]
\end{enumerate}

Portanto, o número total de operações é proporcional a:
\[
T(n, k) = O(k) + O(n) + O(k) + O(n) + O(n) = O(n + k)
\]

\noindent Em termos assintóticos, podemos escrever:
\[
T(n, k) \leq c_1 \cdot n + c_2 \cdot k
\]
para constantes $c_1, c_2 > 0$. Logo:
\[
T(n, k) \in O(n + k)
\]

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n + k)$, pois todos os \textit{loops} sempre executam a mesma quantidade de iterações, independentemente da ordem dos elementos.
    
    \item \textbf{Caso médio:} $O(n + k)$, pois a complexidade depende apenas do tamanho do vetor e do domínio $k$, não da disposição dos elementos.
    
    \item \textbf{Pior caso:} $O(n + k)$, mesmo raciocínio: a ordem dos elementos não altera o número de operações.
\end{itemize}

\section{Radix sort}
\textbf{Descrição:} O Radix Sort ordena números inteiros processando dígito por dígito, da menor para a maior ordem, utilizando Counting Sort como sub-rotina estável. É eficiente quando o número de dígitos $d$ não é muito grande e o domínio dos dígitos é pequeno.

\begin{exmp}
Considere ordenar o vetor $A = [170, 45, 75, 90, 802, 24, 2, 66]$ usando o \textit{Radix Sort}.  

\begin{enumerate}
    \item \textbf{Ordenação pelo dígito das unidades:}  
    Extraímos o dígito das unidades de cada elemento e aplicamos Counting Sort:  
    dígitos das unidades = [0,5,5,0,2,4,2,6]  
    Após o Counting Sort pelos dígitos das unidades, o vetor fica: $[170, 90, 802, 2, 24, 45, 75, 66]$.

    \item \textbf{Ordenação pelo dígito das dezenas:}  
    Extraímos o dígito das dezenas e aplicamos Counting Sort:  
    dígitos das dezenas = [7,9,0,0,2,4,7,6]  
    Após o Counting Sort pelos dígitos das dezenas, o vetor fica: $[802, 2, 24, 45, 66, 170, 75, 90]$.

    \item \textbf{Ordenação pelo dígito das centenas:}  
    Extraímos o dígito das centenas e aplicamos Counting Sort:  
    dígitos das centenas = [1,0,0,0,8,0,0,0]  
    Após o Counting Sort pelos dígitos das centenas, o vetor final ordenado é: $[2, 24, 45, 66, 75, 90, 170, 802]$.
\end{enumerate}
\end{exmp}


\begin{center}
\begin{minipage}{.9\linewidth}
\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{radixSort(values: array of int, n: integer)}

$m \gets$ maior valor em values\;
$exp \gets 1$\;
\While{$m / exp > 0$}{
    countingSort(values, n, exp)\;
    $exp \gets exp \times 10$\;
}
\caption{Radix sort.}
\label{lab:alg-radixSort}
\end{algorithm}
\end{minipage}
\end{center}

\begin{lstlisting}[language=C,caption={Radix sort em C},captionpos=t]
void countingSortRadix(int arr[], int n, int exp) {
    int output[n], count[10] = {0};
    for(int i=0; i<n; i++)
        count[(arr[i]/exp)%10]++;
    for(int i=1; i<10; i++)
        count[i] += count[i-1];
    for(int i=n-1; i>=0; i--) {
        output[count[(arr[i]/exp)%10]-1] = arr[i];
        count[(arr[i]/exp)%10]--;
    }
    for(int i=0; i<n; i++) arr[i] = output[i];
}

void radixSort(int arr[], int n) {
    int m = arr[0];
    for(int i=1; i<n; i++)
        if(arr[i] > m) m = arr[i];
    int exp = 1;
    while(m/exp > 0) {
        countingSort(arr, n, exp);
        exp *= 10;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Radix sort em C++},captionpos=t]
#include <vector>
#include <algorithm>
using namespace std;

void countingSortRadix(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n);
    int count[10] = {0};

    for (int num : arr)
        count[(num / exp) % 10]++;

    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];

    for (int i = n - 1; i >= 0; i--) {
        int idx = (arr[i] / exp) % 10;
        output[count[idx] - 1] = arr[i];
        count[idx]--;
    }

    arr = output;
}

void radixSort(vector<int>& arr) {
    int m = *max_element(arr.begin(), arr.end());
    for (int exp = 1; m / exp > 0; exp *= 10)
        countingSortRadix(arr, exp);
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Radix sort em Python},captionpos=t]
def counting_sort_radix(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    for num in arr:
        index = (num // exp) % 10
        count[index] += 1
    for i in range(1, 10):
        count[i] += count[i-1]
    for num in reversed(arr):
        index = (num // exp) % 10
        output[count[index]-1] = num
        count[index] -= 1
    return output

def radix_sort(arr):
    m = max(arr)
    exp = 1
    while m // exp > 0:
        arr = counting_sort_radix(arr, exp)
        exp *= 10
    return arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-radixSort}}

Seja $n$ o número de elementos e $d$ o número de dígitos no maior valor. Cada passo de Counting Sort tem complexidade $O(n + k)$, onde $k=10$ (base decimal). Assim:

\[
T(n) = d \cdot O(n + k) = O(d \cdot (n + k))
\]

\begin{itemize}
    \item \textbf{Melhor caso:} $O(d \cdot (n+k))$, todos os elementos já ordenados não alteram o número de iterações.
    \item \textbf{Caso médio:} $O(d \cdot (n+k))$, a complexidade depende do número de dígitos $d$.
    \item \textbf{Pior caso:} $O(d \cdot (n+k))$, ordem dos elementos não influencia.
\end{itemize}

Complexidade de espaço: $O(n+k)$ para armazenar o vetor de contagem e o vetor de saída.

\section{Bucket sort}
\textbf{Descrição:} O Bucket Sort distribui os elementos em "baldes" (\textit{buckets}), ordena cada balde individualmente (geralmente com Insertion Sort) e depois concatena os baldes. Funciona melhor quando os elementos estão distribuídos uniformemente.

\begin{exmp}
Considere ordenar o vetor $A = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]$ usando o \textit{Bucket Sort}.  

\begin{enumerate}
    \item \textbf{Distribuição nos baldes:}  
    Criamos $n = 10$ baldes (um para cada faixa de 0.0 a 1.0) e distribuímos cada elemento de $A$ no balde correspondente:  
    \begin{itemize}
        \item Balde 0: [0.12]  
        \item Balde 1: [0.17, 0.21, 0.23, 0.26]  
        \item Balde 2: [0.39]  
        \item Balde 6: [0.68, 0.72, 0.78]  
        \item Balde 9: [0.94]
    \end{itemize}

    \item \textbf{Ordenação de cada balde:}  
    Aplicamos Insertion Sort dentro de cada balde:
    \begin{itemize}
        \item Balde 1: [0.17, 0.21, 0.23, 0.26] (já ordenado)  
        \item Balde 6: [0.68, 0.72, 0.78] (já ordenado)  
        \item Os demais baldes contêm apenas um elemento.
    \end{itemize}

    \item \textbf{Concatenação dos baldes:}  
    Unimos todos os baldes em ordem, obtendo o vetor final ordenado:  
    $[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]$.
\end{enumerate}
\end{exmp}

\begin{center}
\begin{minipage}{.9\linewidth}
\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{bucketSort(values: array of float, n: integer)}

\For{$i \gets 0$ \KwTo $n-1$}{
    distribuir values[i] em um balde\;
}
\For{cada balde $b$}{
    ordenar $b$ com insertionSort\;
}
concatenar todos os baldes em ordem\;

\caption{Bucket sort.}
\label{lab:alg-bucketSort}
\end{algorithm}
\end{minipage}
\end{center}

\begin{lstlisting}[language=C,caption={Bucket sort em C},captionpos=t]
void insertionSort(float arr[], int n) {
    for(int i=1;i<n;i++){
        float key=arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}

void bucketSort(float arr[], int n){
    float buckets[n][n]; int count[n]={0};
    for(int i=0;i<n;i++){
        int index = n*arr[i];
        buckets[index][count[index]++] = arr[i];
    }
    for(int i=0;i<n;i++)
        insertionSort(buckets[i], count[i]);
    int idx=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<count[i];j++)
            arr[idx++] = buckets[i][j];
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Bucket sort em C++},captionpos=t]
#include <vector>
#include <algorithm>
using namespace std;

void insertionSort(vector<float>& arr) {
    for (int i = 1; i < arr.size(); i++) {
        float key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

void bucketSort(vector<float>& arr) {
    int n = arr.size();
    vector<vector<float>> buckets(n);

    for (float num : arr) {
        int idx = n * num;
        buckets[idx].push_back(num);
    }

    for (auto& b : buckets)
        insertionSort(b);

    arr.clear();
    for (auto& b : buckets)
        arr.insert(arr.end(), b.begin(), b.end());
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Bucket sort em Python},captionpos=t]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

def bucket_sort(arr):
    n = len(arr)
    buckets = [[] for _ in range(n)]
    for num in arr:
        index = int(n*num)
        buckets[index].append(num)
    for i in range(n):
        buckets[i] = insertion_sort(buckets[i])
    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)
    return sorted_arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-bucketSort}}

Seja $n$ o número de elementos:

\begin{itemize}
    \item Distribuição nos baldes: $O(n)$
    \item Ordenação dos baldes (Insertion Sort): no caso médio $O(n)$, assumindo distribuição uniforme
    \item Concatenação dos baldes: $O(n)$
\end{itemize}

Portanto, a complexidade total no **caso médio** é:

\[
T(n) = O(n) + O(n) + O(n) = O(n)
\]

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$, quando os elementos são distribuídos uniformemente.
    \item \textbf{Caso médio:} $O(n)$, para distribuição uniforme.
    \item \textbf{Pior caso:} $O(n^2)$, se todos os elementos caírem no mesmo balde (Insertion Sort domina).
\end{itemize}

Complexidade de espaço: $O(n + k)$, onde $k$ é o número de baldes (geralmente $k=n$).

\section{Spreadsort}
\textbf{Descrição:} O \textit{Spreadsort} é um algoritmo híbrido que combina ideias do \textit{Radix Sort} e do \textit{Quicksort}. Ele distribui os elementos em intervalos (\textit{buckets}) de acordo com os bits mais significativos, e em seguida ordena recursivamente os intervalos menores. Essa abordagem permite obter desempenho linear em média, com comportamento próximo de $O(n \log n)$ em casos degenerados.

\begin{exmp}
Considere ordenar o vetor $A = [32, 5, 10, 40, 7, 25, 1]$.  
O algoritmo distribui os elementos em intervalos baseados em seus bits mais significativos (por exemplo, de 0 a 15, 16 a 31, 32 a 47).  
Assim, teríamos os grupos:  
$G_1 = [5, 10, 7, 1]$, $G_2 = [25]$, $G_3 = [32, 40]$.  
Cada grupo é ordenado internamente (usando \textit{insertion sort} ou similar) e os grupos são concatenados:  
$[1, 5, 7, 10, 25, 32, 40]$.
\end{exmp}

\begin{center}
\begin{minipage}{.9\linewidth}
\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{spreadsort(values: array of int, n: integer)}
\If{$n \leq 1$}{
    \Return
}
Distribuir $values$ em intervalos com base nos bits mais significativos\;
\For{intervalo $b$}{
    \textbf{spreadsort}($b$)\;
}
Concatenar todos os intervalos ordenados\;
\caption{Spreadsort.}
\label{lab:alg-spreadsort}
\end{algorithm}
\end{minipage}
\end{center}

\vspace{1em}

\begin{lstlisting}[language=C,caption={Spreadsort em C},captionpos=t]
#include <stdio.h>

void spreadsort(int arr[], int left, int right) {
    if(right - left <= 1) return;
    int min = arr[left], max = arr[left];
    for(int i = left+1; i < right; i++) {
        if(arr[i] < min) min = arr[i];
        if(arr[i] > max) max = arr[i];
    }
    if(min == max) return;

    int pivot = (min + max) / 2;
    int i = left, j = right-1;
    while(i <= j) {
        while(arr[i] <= pivot) i++;
        while(arr[j] > pivot) j--;
        if(i < j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; i++; j--; }
    }
    spreadsort(arr, left, i);
    spreadsort(arr, i, right);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Spreadsort em C++},captionpos=t]
#include <vector>
#include <algorithm>
using namespace std;

void spreadsort(vector<int>& arr, int left, int right) {
    if(right - left <= 1) return;
    int min_val = *min_element(arr.begin() + left, arr.begin() + right);
    int max_val = *max_element(arr.begin() + left, arr.begin() + right);
    if(min_val == max_val) return;

    int pivot = (min_val + max_val)/2;
    int i = left, j = right-1;
    while(i <= j) {
        while(arr[i] <= pivot) i++;
        while(arr[j] > pivot) j--;
        if(i < j) swap(arr[i++], arr[j--]);
    }
    spreadsort(arr, left, i);
    spreadsort(arr, i, right);
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Spreadsort em Python},captionpos=t]
def spreadsort(arr):
    if len(arr) <= 1:
        return arr
    min_val, max_val = min(arr), max(arr)
    if min_val == max_val:
        return arr
    pivot = (min_val + max_val) // 2
    left = [x for x in arr if x <= pivot]
    right = [x for x in arr if x > pivot]
    return spreadsort(left) + spreadsort(right)
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-spreadsort}}

O tempo de execução depende da distribuição dos elementos:
\[
T(n) = O(n) \text{ (médio)} \quad \text{e} \quad T(n) = O(n \log n) \text{ (pior caso)}.
\]

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$ — elementos bem distribuídos entre intervalos.
    \item \textbf{Caso médio:} $O(n)$.
    \item \textbf{Pior caso:} $O(n \log n)$ — todos os elementos caem em um mesmo intervalo.
\end{itemize}

\section{Burstsort}
\textbf{Descrição:} O \textit{Burstsort} é otimizado para ordenar grandes coleções de \textit{strings}. Ele constrói uma \textit{trie} de prefixos onde cada nó contém um pequeno vetor (“balde”) de palavras que compartilham prefixos comuns. Quando um balde fica cheio, ele “explode” (\textit{burst}) em nós filhos, permitindo divisão eficiente e comportamento quase linear.

\begin{exmp}
Dado $A = [\text{'car'}, \text{'cat'}, \text{'dog'}, \text{'door'}]$, a \textit{trie} começa com o prefixo inicial. As palavras “car” e “cat” compartilham o prefixo “ca”, então ficam no mesmo balde. Quando o balde se divide, temos nós separados: “car” e “cat”, e outro ramo para “do”. No final, as palavras são lidas em ordem lexicográfica.
\end{exmp}

\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{burstsort(words: array of string)}
\If{$|words| \leq 1$}{\Return}
Construir \textit{trie} de prefixos\;
\For{balde $b$ na \textit{trie}}{
    Ordenar $b$ internamente (ex: \textit{insertion sort})\;
}
Concatenar os baldes em ordem lexicográfica\;
\caption{Burstsort.}
\label{lab:alg-burstsort}
\end{algorithm}

\begin{lstlisting}[language=C,caption={Burstsort em C},captionpos=t]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STR 100
typedef struct Node {
    char* str;
    struct Node* next;
} Node;

void burstsort(char* arr[], int n) {
    Node* buckets[256] = {NULL};
    for(int i=0;i<n;i++){
        unsigned char c = (unsigned char)arr[i][0];
        Node* node = malloc(sizeof(Node));
        node->str = arr[i];
        node->next = buckets[c];
        buckets[c] = node;
    }
    int index = 0;
    for(int i=0;i<256;i++){
        Node* current = buckets[i];
        while(current){
            arr[index++] = current->str;
            Node* tmp = current;
            current = current->next;
            free(tmp);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Burstsort em C++},captionpos=t]
#include <vector>
#include <string>
#include <list>
using namespace std;

void burstsort(vector<string>& arr) {
    list<string> buckets[256];
    for(const auto& s : arr) buckets[(unsigned char)s[0]].push_back(s);
    arr.clear();
    for(int i=0;i<256;i++)
        for(auto& s : buckets[i]) arr.push_back(s);
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Burstsort em Python},captionpos=t]
def burstsort(arr):
    buckets = [[] for _ in range(256)]
    for s in arr:
        buckets[ord(s[0])].append(s)
    sorted_arr = []
    for b in buckets:
        sorted_arr.extend(b)
    return sorted_arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-burstsort}}

O tempo é linear em relação ao número total de caracteres:
\[
T(n, L) = O(n + L)
\]
onde $L$ é o comprimento total das \textit{strings}.

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$.
    \item \textbf{Caso médio:} $O(n)$.
    \item \textbf{Pior caso:} $O(n \log n)$ (degrada quando todos os prefixos são iguais).
\end{itemize}

\section{Flashsort}

\textbf{Descrição:} O \textit{Flashsort} é um algoritmo de distribuição linear que estima a posição final de cada elemento com base em uma função de mapeamento linear. Ele divide os dados em classes, rearranja os elementos em torno de suas classes e, dentro de cada classe, aplica uma ordenação auxiliar como o \textit{insertion sort}.

\begin{exmp}
Dado $A = [8, 3, 1, 7, 0, 10, 2]$, o algoritmo estima o número de classes (por exemplo, 3) e distribui os elementos de acordo com o valor relativo.  
Classes: $C_1 = [0, 1, 2]$, $C_2 = [3, 7, 8]$, $C_3 = [10]$.  
Após ordenar internamente: $[0, 1, 2, 3, 7, 8, 10]$.
\end{exmp}

\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{flashsort(values: array of int, n: integer)}
\If{$n \leq 1$}{\Return}
Determinar número de classes $m$\;
Calcular posição de classe de cada elemento\;
Distribuir elementos nas classes\;
Ordenar cada classe localmente\;
Concatenar classes\;
\caption{Flashsort.}
\label{lab:alg-flashsort}
\end{algorithm}

\begin{lstlisting}[language=C,caption={Flashsort em C},captionpos=t]
#include <stdio.h>

void flashsort(int arr[], int n) {
    int m = (int)(0.45*n);
    int L[m];
    for(int i=0;i<m;i++) L[i]=0;

    int min=arr[0], max=arr[0];
    for(int i=1;i<n;i++){
        if(arr[i]<min) min=arr[i];
        if(arr[i]>max) max=arr[i];
    }
    if(min==max) return;

    double c1 = (double)(m-1)/(max-min);
    for(int i=0;i<n;i++){
        int k = (int)(c1*(arr[i]-min));
        L[k]++;
    }
    for(int i=1;i<m;i++) L[i]+=L[i-1];

    int count=0,j=0,k=m-1;
    while(count<n){
        while(j>=L[k]) k--;
        int evicted=arr[j];
        while(j!=L[k]-1){
            k=(int)(c1*(evicted-min));
            int tmp=arr[L[k]-1];
            arr[L[k]-1]=evicted;
            evicted=tmp;
            L[k]--;
            count++;
        }
        count++;
        j++;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Flashsort em C++},captionpos=t]
#include <vector>
#include <algorithm>
using namespace std;

void flashsort(vector<int>& arr) {
    int n = arr.size();
    int m = int(0.45*n);
    vector<int> L(m,0);

    int min_val = *min_element(arr.begin(), arr.end());
    int max_val = *max_element(arr.begin(), arr.end());
    if(min_val==max_val) return;

    double c1 = (double)(m-1)/(max_val-min_val);
    for(int i=0;i<n;i++){
        int k=int(c1*(arr[i]-min_val));
        L[k]++;
    }
    for(int i=1;i<m;i++) L[i]+=L[i-1];

    int count=0, j=0, k=m-1;
    while(count<n){
        while(j>=L[k]) k--;
        int evicted=arr[j];
        while(j!=L[k]-1){
            k=int(c1*(evicted-min_val));
            swap(evicted, arr[L[k]-1]);
            L[k]--;
            count++;
        }
        count++;
        j++;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Flashsort em Python},captionpos=t]
def flashsort(arr):
    n = len(arr)
    m = int(0.45*n)
    L = [0]*m
    min_val, max_val = min(arr), max(arr)
    if min_val==max_val: return arr
    c1 = (m-1)/(max_val-min_val)
    for x in arr:
        k = int(c1*(x-min_val))
        L[k]+=1
    for i in range(1,m):
        L[i]+=L[i-1]
    count, j = 0, 0
    while count<n:
        while j>=len(L): L.pop()
        evicted = arr[j]
        while True:
            k = int(c1*(evicted-min_val))
            arr[L[k]-1], evicted = evicted, arr[L[k]-1]
            L[k]-=1
            count+=1
            if j==L[k]: break
        j+=1
    return arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-flashsort}}

\[
T(n) = O(n) \text{ (médio)}, \quad T(n) = O(n^2) \text{ (pior caso)}.
\]
\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$.
    \item \textbf{Caso médio:} $O(n)$.
    \item \textbf{Pior caso:} $O(n^2)$ (má distribuição dos elementos).
\end{itemize}

\section{Postman Sort}

\textbf{Descrição:} O \textit{Postman Sort} (ou \textit{Postal Sort}) é um algoritmo linear baseado em ordenação por dígitos, semelhante ao \textit{Radix Sort}. Ele processa os elementos em múltiplas passagens, ordenando de acordo com cada posição (dígito) da chave.

\begin{exmp}
Para $A = [321, 212, 132, 231]$, o algoritmo ordena por dígito menos significativo (unidades), depois dezenas e centenas.  
Após todas as passagens: $[132, 212, 231, 321]$.
\end{exmp}

\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{postmanSort(values: array of int, n: integer, d: integer)}
\For{$i \gets 0$ \KwTo $d-1$}{
    Aplicar \textbf{Counting Sort} baseado no $i$-ésimo dígito\;
}
\caption{Postman sort.}
\label{lab:alg-postmansort}
\end{algorithm}

\begin{lstlisting}[language=C,caption={Postman Sort em C},captionpos=t]
#include <stdio.h>
#include <string.h>

void postmanSort(int arr[], int n, int base) {
    int max=arr[0]; for(int i=1;i<n;i++) if(arr[i]>max) max=arr[i];
    int exp=1;
    int output[n];
    while(max/exp>0){
        int count[base]; for(int i=0;i<base;i++) count[i]=0;
        for(int i=0;i<n;i++) count[(arr[i]/exp)%base]++;
        for(int i=1;i<base;i++) count[i]+=count[i-1];
        for(int i=n-1;i>=0;i--){
            output[count[(arr[i]/exp)%base]-1]=arr[i];
            count[(arr[i]/exp)%base]--;
        }
        for(int i=0;i<n;i++) arr[i]=output[i];
        exp*=base;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Postman Sort em C++},captionpos=t]
#include <vector>
using namespace std;

void postmanSort(vector<int>& arr, int base) {
    int n=arr.size();
    int max_val=*max_element(arr.begin(), arr.end());
    int exp=1;
    vector<int> output(n);
    while(max_val/exp>0){
        vector<int> count(base,0);
        for(int num: arr) count[(num/exp)%base]++;
        for(int i=1;i<base;i++) count[i]+=count[i-1];
        for(int i=n-1;i>=0;i--){
            output[count[(arr[i]/exp)%base]-1]=arr[i];
            count[(arr[i]/exp)%base]--;
        }
        arr=output;
        exp*=base;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Postman Sort em Python},captionpos=t]
def postman_sort(arr, base=10):
    max_val = max(arr)
    exp = 1
    n = len(arr)
    output = [0]*n
    while max_val//exp > 0:
        count = [0]*base
        for num in arr:
            count[(num//exp)%base] += 1
        for i in range(1, base):
            count[i] += count[i-1]
        for i in reversed(range(n)):
            idx = (arr[i]//exp)%base
            output[count[idx]-1] = arr[i]
            count[idx] -= 1
        arr = output[:]
        exp *= base
    return arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-postmansort}}

\[
T(n, d) = O(d \cdot (n + k))
\]
onde $d$ é o número de dígitos e $k$ o intervalo de cada dígito (geralmente 10).

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$.
    \item \textbf{Caso médio:} $O(n)$.
    \item \textbf{Pior caso:} $O(n)$ (pois $d$ é constante para inteiros fixos).
\end{itemize}

\section{Bead Sort}

\textbf{Descrição:} O \textit{Bead Sort} (ou \textit{Gravity Sort}) é inspirado em contas que caem sob a gravidade. Cada número é representado por uma coluna de contas, e as contas “caem” para o nível mais baixo possível. Após estabilização, as colunas resultam em uma sequência ordenada.

\begin{exmp}
Para $A = [5, 3, 1, 7, 4]$, cada número é representado com 7 posições de contas.  
Após deixar as “contas caírem”, o resultado visual reflete os números ordenados: $[1, 3, 4, 5, 7]$.
\end{exmp}

\begin{algorithm}[H]
\DontPrintSemicolon
\textbf{beadSort(values: array of int, n: integer)}
Criar matriz de contas (n linhas, max colunas)\;
Deixar as contas “caírem” somando as colunas\;
Reconstruir os valores com base na altura das contas\;
\caption{Bead sort.}
\label{lab:alg-beadsort}
\end{algorithm}

\begin{lstlisting}[language=C,caption={Bead Sort em C},captionpos=t]
#include <stdio.h>
#include <stdlib.h>

void bead_sort(int arr[], int n) {
    int max=arr[0];
    for(int i=1;i<n;i++) if(arr[i]>max) max=arr[i];
    int **beads = malloc(n*sizeof(int*));
    for(int i=0;i<n;i++){
        beads[i] = calloc(max,sizeof(int));
        for(int j=0;j<arr[i];j++) beads[i][j]=1;
    }
    for(int j=0;j<max;j++){
        int sum=0;
        for(int i=0;i<n;i++) { sum+=beads[i][j]; beads[i][j]=0; }
        for(int i=n-sum;i<n;i++) beads[i][j]=1;
    }
    for(int i=0;i<n;i++){
        int count=0;
        for(int j=0;j<max;j++) if(beads[i][j]) count++;
        arr[i]=count;
        free(beads[i]);
    }
    free(beads);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Bead Sort em C++},captionpos=t]
#include <vector>
using namespace std;

void bead_sort(vector<int>& arr) {
    int n = arr.size();
    int max_val = *max_element(arr.begin(), arr.end());
    vector<vector<int>> beads(n, vector<int>(max_val,0));

    for(int i=0;i<n;i++)
        for(int j=0;j<arr[i];j++)
            beads[i][j]=1;

    for(int j=0;j<max_val;j++){
        int sum=0;
        for(int i=0;i<n;i++){ sum+=beads[i][j]; beads[i][j]=0; }
        for(int i=n-sum;i<n;i++) beads[i][j]=1;
    }

    for(int i=0;i<n;i++){
        int count=0;
        for(int j=0;j<max_val;j++) if(beads[i][j]) count++;
        arr[i]=count;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Python,caption={Bead Sort em Python},captionpos=t]
def bead_sort(arr):
    if any(x<0 for x in arr): raise ValueError("Apenas inteiros n\~ao-negativos")
    n = len(arr)
    max_val = max(arr)
    beads = [[0]*max_val for _ in range(n)]
    for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1
    for j in range(max_val):
        sum_col = sum(beads[i][j] for i in range(n))
        for i in range(n):
            beads[i][j] = 1 if i >= n - sum_col else 0
    for i in range(n):
        arr[i] = sum(beads[i])
    return arr
\end{lstlisting}

\subsection{Análise de complexidade do algoritmo \ref{lab:alg-beadsort}}

\[
T(n, m) = O(n \cdot m)
\]
onde $m$ é o maior valor do vetor.

\begin{itemize}
    \item \textbf{Melhor caso:} $O(n)$ (para pequenos inteiros).
    \item \textbf{Caso médio:} $O(n \cdot m)$.
    \item \textbf{Pior caso:} $O(n)$.
\end{itemize}

\textcolor{blue}{Aline, leia os textos nos \textit{links} abaixo e tente melhor o seu texto neste capítulo}: 
\begin{itemize}
    \item 
\href{https://www.ic.unicamp.br/~ra063658/disciplinas/stco02_2025s1/sort_linear.pdf}{Sorting in Linear Time};

\item \href{https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/bf7d79105762bf79bbc0925438e1468a_MIT6_006F11_lec07.pdf}{Linear-time sorting};

\item  \href{https://iudatastructurescourse.github.io/course-web-page-fall-2024/lectures/sort-linear.html}{Sorting in linear time};

\item \href{http://personal.kent.edu/~amohamm4/daa-f2019/slides/ch4-2%20LinearTime%20Sorting.pdf}{Linear-time sorting};

\item
\href{https://www.dcc.fc.up.pt/~pribeiro/aulas/aed2425/slides/4_sorting.pdf}{Sorting Algorithms}.
\end{itemize}